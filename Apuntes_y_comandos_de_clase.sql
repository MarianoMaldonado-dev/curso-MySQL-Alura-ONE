USE JUGOS_VENTAS;
SELECT * FROM facturas;
SELECT NOMBRE, DNI, DIRECCION_1, DIRECCION_2, BARRIO, CIUDAD, ESTADO,
CP, FECHA_DE_NACIMIENTO, EDAD, SEXO, LIMITE_DE_CREDITO, VOLUMEN_DE_COMPRA,
PRIMERA_COMPRA FROM TABLA_DE_CLIENTES;
SELECT * FROM TABLA_DE_CLIENTES;
/*
			ACERCA DE ESTE CURSO
ESTE ES EL CURSO BASICO INICIAL DE SQL CON MySQL DICTADO POR ALURA LATAM DENTRO DE LA BECA ORACLE NEXT EDUCATION
SI ES SU PRIMERA VEZ APRENDIENDO SQL, PORFAVOR, NO COMETA LA EQUIVOCACION DE EJECUTAR ESTE SCRIPT COMPLETAMENTE
DEBIDO A QUE HARA UN PROCESO DE EJECUCION QUE ELEVARA EL USO DE RECURSOS DE SU SISTEMA.

SI AUN NO TIENE EL ESQUEMA Y LA ESTRUCTURA DE ESTA BASE DE DATOS, PUEDE ENCONTRARLA O COMPARARLA EN EL SIGUIENTE ENLACE:
https://github.com/alura-es-cursos/1827-consultas-sql-avanzando-en-sql-con-my-sql

	LA FORMA MAS ADECUADA DE EJECUTAR ESTE SCRIPT ES SELECIONAR LINEA A LINEA YA QUE CADA 'SELECT' CORRESPONDE A UNA CONSULTA.

EN SQL existe varias subcategorías que tienen roles específicos, como:

    DML (Data Manipulation Language): Se utiliza para manejar los datos dentro de las tablas. Incluye comandos como SELECT, INSERT, UPDATE, y DELETE.

    DDL (Data Definition Language): Se utiliza para definir y modificar la estructura de las bases de datos y sus objetos. Incluye comandos como CREATE, ALTER, y DROP.

    DCL (Data Control Language): Se usa para controlar el acceso a los datos y la seguridad. Incluye comandos como GRANT y REVOKE.

    TCL (Transaction Control Language): Maneja las transacciones en una base de datos, asegurando que las operaciones se completen de manera correcta y coherente. Incluye comandos como COMMIT, ROLLBACK, y SAVEPOINT.
    
ESTE SCRIPT UTILIZA DML COMO APRENDIZAJE INICIAL. PUEDE UTILIZAR ESTA BASE DE DATOS CON CUALQUIER CURSO SQL QUE USTED HAGA
Y ADAPTAR LOS COMANDOS DE CONSULTA DE SU CURSO PARA QUE COINCIDA CON LOS DATOS AQUI PROPORCIONADOS.
	SIENTA LIBRE, INCLUSIVE, DE UTILIZAR CRUD A SU MANERA PARA MODIFICAR TODO, YA QUE LA FINALIDAD DE ESTO ES APRENDER BASES DE DATOS.

Un cordial Saludo!
	Mariano Maldonado
https://github.com/MarianoMaldonado-dev/
*/

SELECT DNI, NOMBRE FROM TABLA_DE_CLIENTES;
SELECT DNI AS IDENTIFICATION, NOMBRE AS CLIENTE FROM TABLA_DE_CLIENTES;
SELECT * FROM tabla_de_productos;
SELECT * FROM tabla_de_productos WHERE SABOR = 'UVA';
SELECT * FROM tabla_de_productos WHERE SABOR = 'MANGO';
SELECT * FROM tabla_de_productos WHERE ENVASE = 'BOTELLA PET';
SELECT * FROM tabla_de_productos WHERE PRECIO_DE_LISTA > 16;
SELECT * FROM tabla_de_productos WHERE PRECIO_DE_LISTA <= 17;
SELECT * FROM tabla_de_productos WHERE PRECIO_DE_LISTA BETWEEN 16 AND 16.02;

/*OPERACION OR: DEVOLVERA RESULTADOS VERDADEROS SI ALGUNA DE LAS CONDICIONES ES VERDADERA

OPERACION AND: DEVOLVERA RESULTADOS VERDADEROS SI TODAS SUS CONDICIONES SON VERDADERAS

OPERACION NOR (NOT OR): LA NEGACION DE LA OPERACION OR

OPERACION NAND (NOT AND): LA NEGACION DE LA OPERACION AND

VERDADERO = 1
FALSO = 0
*/

SELECT * FROM tabla_de_productos where SABOR='MANGO' AND TAMANO='470 ML';
SELECT * FROM tabla_de_productos where SABOR='MANGO' OR TAMANO='470 ML';
SELECT * FROM tabla_de_productos where NOT (SABOR='MANGO') OR TAMANO='470 ML';
SELECT * FROM tabla_de_productos where SABOR='MANGO' AND NOT (TAMANO='470 ML');
SELECT * FROM tabla_de_productos where SABOR IN ('MANGO', 'UVA');
SELECT * FROM tabla_de_productos where SABOR = 'MANGO' OR SABOR = 'UVA';

SELECT * FROM tabla_de_clientes WHERE CIUDAD IN ('CIUDAD DE MEXICO0', 'GUADALAJARA');
SELECT * FROM tabla_de_clientes WHERE CIUDAD IN ('CIUDAD DE MEXICO0', 'GUADALAJARA')
AND EDAD > 21;
SELECT * FROM tabla_de_clientes WHERE CIUDAD IN ('CIUDAD DE MEXICO0', 'GUADALAJARA')
AND (EDAD BETWEEN 20 AND 25);

/*
COMANDO LIKE
SELECT * FROM <TB> WHERE <CAMPO> LIKE '%<CONDICION>';

<CONDICION> ES EL TEXTO UTILIZADO
% REPRESENTA CUALQUER REGISTRO GENERICO ANTES DE LA CONDICION.
*/
SELECT * FROM tabla_de_productos WHERE SABOR LIKE '%MANZANA';
SELECT * FROM tabla_de_productos WHERE SABOR LIKE '%MANZANA'
AND ENVASE = 'BOTELLA PET';

/*ACTIVIDAD: CUANTOS CLIENTES TIENEN APELLIDOS QUE ACABAN CON "EZ"*/
SELECT * FROM tabla_de_clientes WHERE NOMBRE LIKE '%EZ'; /*RESUELTO POR MI*/

/*
COMANDO DISTINCT
SOLO DEVUELVE REGISTROS CON VALORES DIFERENTES.

SELECT DISTINCT * FROM <TB>;
*/
SELECT distinct ENVASE, TAMANO FROM tabla_de_productos;
SELECT distinct ENVASE, TAMANO, SABOR FROM tabla_de_productos
WHERE SABOR = 'NARANJA';

/* ACTIVIDAD: ¿CUALES SON LOS BARRIOS EN LA CIUDAD DE MEXICO QUE TIENEN CLIENTES?
*/
SELECT DISTINCT BARRIO FROM tabla_de_clientes WHERE CIUDAD = 'CIUDAD DE MEXICO'; /*MIRE SOLUCION*/

/*
COMANDO LIMIT: LIMITA EL NUMERO DE REGISTROS EXHIBIDOS
SELECT * FROM <tB> LIMIT 4;
ESTA SENTENCIA SE PUEDE ESPECIFICAR MUCHO MAS
SELECT * FROM <TB> LIMIT 3,2;
EL PRIMER NUMERO ES EL INDICE Y EL SEGUNDO DESPUES DE LA  ,  ES LA CANTIDAD DE REGISTROS
QUE QUIERO CONSULTAR
*/
SELECT * FROM tabla_de_productos;
SELECT * FROM tabla_de_productos LIMIT 5;
SELECT * FROM tabla_de_productos LIMIT 5,4; /*ESTA SENTENCIA SIGNIFICA QUE DEVOLVERA RESULTADOS
A PARTIR DE LA POSICION (INDICE) NUMERO 5 Y SOLO LOS PRIMEROS 4 DESPUES DE ESA POSICION*/

/* ACTIVIDAD: SE REQUIERE OBTENER LAS 10 PRIMERAS VENTAS DEL DIA 01/01/2017.
CON CUÁL COMANDO SQL SE PODRÍA OBTENER ESE RESULTADO?
*/
SELECT * FROM facturas WHERE FECHA_VENTA = '2017-01-01' LIMIT 10;

/*COMANDO ORDER BY
PRESENTA EL RESULTADO DE LA CONSULTA ORDENADO POR EL CAMPO DETERMINADO AL EJECUTAR ORDER BY

SELECT * FROM <TB> ORDER BY <CAMPO>;

SE PUEDE HACER EN ORDEN DESCENDENTE
SELECT * FROM <TB> ORDER BY <CAMPO> DESC;

SE PUEDEN EMPLEAR n CAMPOS AL MISMO TEMPO COMO CRITERIO DE SELECCION
SELECT * FROM <TB> ORDER BY <CAMPO_1> DESC, <CAMPO_2> ASC;
*/
SELECT * FROM tabla_de_productos;
SELECT * FROM tabla_de_productos ORDER BY PRECIO_DE_LISTA;
SELECT * FROM tabla_de_productos ORDER BY PRECIO_DE_LISTA DESC;
SELECT * FROM tabla_de_productos ORDER BY NOMBRE_DEL_PRODUCTO;
SELECT * FROM tabla_de_productos ORDER BY NOMBRE_DEL_PRODUCTO DESC;
SELECT * FROM tabla_de_productos ORDER BY ENVASE DESC, NOMBRE_DEL_PRODUCTO ASC;

/* ACTIVIDAD: ¿CUALES FUERON LAS MAYORES VENTAS DEL PRODUCTO 'REFRESCANTE, 1 LITRO, FRUTILLA/LIMON'
EN CANTIDAD?
OBTENGA ESTE RESULTADO UTILIZANDO 2 COMANDOS SQL
*/
SELECT CODIGO_DEL_PRODUCTO FROM TABLA_DE_PRODUCTOS WHERE NOMBRE_DEL_PRODUCTO = "REFRESCANTE" AND
TAMANO = '1 LITRO' AND SABOR = 'FRUTILLA/LIMON';
SELECT * FROM items_facturas WHERE CODIGO_DEL_PRODUCTO = '1101035' ORDER BY CANTIDAD DESC;

/*
COMANDO GROUP BY: PRESENTA EL RESULTADO AGRUPANDO VALORES NUMERICOS EMPLEANDO UNA CLAVE DE CRITERIO.

SELECT <CAMPOS> FROM <TB> GROUP BY <CAMPO>;

TAMBIEN:
SELECT X, SUM(Y) FROM <TB> GROUP BY X;

COMANDOS UTILIZADOS:
SUM() -> SUMA
MAX() -> MAXIMO
MIN() -> MINIMO
AVG() -> PROMEDIO
COUNT() -> CONTADOR

SELECT SUM(Y) FROM <TB>;
SI SE OMITE EL CAMPO DE AGREGACIÓN COMO EN ESTE CASO, LA OPERACION SE VA A EFECTUAR EN TODA LA TABLA.
*/
SELECT ESTADO, LIMITE_DE_CREDITO FROM TABLA_DE_CLIENTES;
SELECT ESTADO, SUM(LIMITE_DE_CREDITO) AS LIMITE_TOTAL FROM TABLA_DE_CLIENTES GROUP BY ESTADO;
SELECT ENVASE, MAX(PRECIO_DE_LISTA) AS MAYOR_PRECIO FROM TABLA_DE_PRODUCTOS group by ENVASE;
SELECT ENVASE, COUNT(*) FROM TABLA_DE_PRODUCTOS group by ENVASE;
SELECT BARRIO, SUM(LIMITE_DE_CREDITO) AS LIMITE FROM TABLA_DE_CLIENTES group by BARRIO;
SELECT CIUDAD, BARRIO, SUM(LIMITE_DE_CREDITO) AS LIMITE FROM TABLA_DE_CLIENTES 
WHERE CIUDAD = 'CIUDAD DE MEXICO' group by BARRIO;
SELECT CIUDAD, BARRIO, SUM(LIMITE_DE_CREDITO) AS LIMITE FROM TABLA_DE_CLIENTES 
WHERE CIUDAD = 'GUADALAJARA' group by BARRIO;
SELECT ESTADO, BARRIO, SUM(LIMITE_DE_CREDITO) AS LIMITE FROM TABLA_DE_CLIENTES group by ESTADO, BARRIO;
SELECT ESTADO, BARRIO, MAX(LIMITE_DE_CREDITO) AS LIMITE, EDAD FROM TABLA_DE_CLIENTES 
WHERE EDAD >=20 group by ESTADO, BARRIO ORDER BY EDAD;

/* COMANDO HAVING:
ES UN FILTRO QUE SE APLICA SOBRE EL RESULTADO DE UNA AGREGACIÓN.
SELECT X, SUM(Y) FROM <TB> GROUP BY X HAVING SUM(Y) > 4;
*/
SELECT ESTADO, SUM(LIMITE_DE_CREDITO) AS LIMITE_TOTAL FROM TABLA_DE_CLIENTES GROUP BY ESTADO;
SELECT ESTADO, SUM(LIMITE_DE_CREDITO) AS LIMITE_TOTAL FROM TABLA_DE_CLIENTES 
WHERE LIMITE_TOTAL > 300000 GROUP BY ESTADO; /* DEVOLVERA UN ERROR */
SELECT ESTADO, SUM(LIMITE_DE_CREDITO) AS LIMITE_TOTAL FROM TABLA_DE_CLIENTES 
GROUP BY ESTADO HAVING LIMITE_TOTAL > 300000;
SELECT ENVASE, MAX(PRECIO_DE_LISTA) AS PRECIO_MAXIMO, MIN(PRECIO_DE_LISTA) AS PRECIO_MINIMO
FROM TABLA_DE_PRODUCTOS GROUP BY ENVASE;
SELECT ENVASE, MAX(PRECIO_DE_LISTA) AS PRECIO_MAXIMO, MIN(PRECIO_DE_LISTA) AS PRECIO_MINIMO
FROM TABLA_DE_PRODUCTOS GROUP BY ENVASE HAVING MAX(PRECIO_DE_LISTA) > 80;
SELECT ENVASE, MAX(PRECIO_DE_LISTA) AS PRECIO_MAXIMO, MIN(PRECIO_DE_LISTA) AS PRECIO_MINIMO,
SUM(PRECIO_DE_LISTA) AS SUMA_PRECIO FROM TABLA_DE_PRODUCTOS 
GROUP BY ENVASE HAVING MAX(PRECIO_DE_LISTA) <= 80 AND MAX(PRECIO_DE_LISTA) >= 5;

/* COMANDO CASE:
SE REALIZA UN TEST EN UNO O MAS CAMPOS Y, DEPENDIENDO DEL RESULTADO, OBTENDREMOS UN VALOR ESPECIFICO
SELECT X
CASE
	WHEN <CONDICION_1> THEN <VALUE_1>
    WHEN <CONDICION_2> THEN <VALUE_2>
    
    WHEN <CONDICION_n> THEN <VALUE_n>
    ELSE <VALOR_ELSE>
END

USANDO UN EJEMPLO:
SELECT X
	CASE
		WHEN Y >= 8 AND Y <= 10 THEN 'MUY BUENO'
        WHEN Y >= 7 AND Y < 8 THEN 'BUENO'
        WHEN Y >= 5 AND Y < 7 THEN 'REGULAR'
        ELSE 'MALO'
	END
FROM <TB>;
*/
SELECT * FROM TABLA_DE_PRODUCTOS;
SELECT NOMBRE_DEL_PRODUCTO, PRECIO_DE_LISTA,
	CASE
		WHEN PRECIO_DE_LISTA >= 12 THEN 'COSTOSO'
        WHEN PRECIO_DE_LISTA >= 5 AND PRECIO_DE_LISTA < 12 THEN 'ASEQUIBLE'
	ELSE 'BARATO'
    END AS PRECIO
FROM TABLA_DE_PRODUCTOS;

SELECT NOMBRE,
	CASE
			WHEN YEAR(FECHA_DE_NACIMIENTO) < 1990 THEN 'VIEJOS'
			WHEN YEAR(FECHA_DE_NACIMIENTO) >= 1990 AND YEAR(FECHA_DE_NACIMIENTO) <= 1995 THEN 'JOVENES'
		ELSE 'NIÑOS'
    END AS CLASIFICACION_EDAD
    FROM TABLA_DE_CLIENTES;
    
SELECT ENVASE, SABOR,
	CASE
		WHEN PRECIO_DE_LISTA >= 12 THEN 'COSTOSO'
        WHEN PRECIO_DE_LISTA >= 5 AND PRECIO_DE_LISTA < 12 THEN 'ASEQUIBLE'
	ELSE 'BARATO'
    END AS PRECIO, MIN(PRECIO_DE_LISTA) AS PRECIO_MINIMO FROM TABLA_DE_PRODUCTOS WHERE TAMANO = '700 ML'
GROUP BY ENVASE,
	CASE
		WHEN PRECIO_DE_LISTA >= 12 THEN 'COSTOSO'
        WHEN PRECIO_DE_LISTA >= 5 AND PRECIO_DE_LISTA < 12 THEN 'ASEQUIBLE'
	ELSE 'BARATO'
    END
    ORDER BY ENVASE;

/* ACTIVIDAD: REGISTRE EL AÑO DE NACIMIENTO DE LOS CLIENTES Y CLASIFIQUELOS DE LA SIGUIENTE MANERA:

NACIDOS ANTES DE 1990 = VIEJOS 
NACIDOS ENTRE 1990 Y 1995 = JOVENES
NACIDOS DESPUES DE 1995 = NIÑIS

LISTE EL NOMBRE DEL CLIENTE Y ESTA CLASIFICACION
*/
    
    /* Estructura JOIN
Permite unir 2 o más tablas a través de un campo en común

1. INNER JOIN: Devuelve nicamente los registros con llaves correspondientes
	SELECT A.NOMBRE, B.HOBBY FROM <TABLA_IZQ A>
		INNER JOIN
			<TABLA_DER B>
				ON A.ID = B.ID
                
2. LEFT JOIN: Mantiene todos los registros de la tabla de la izquierda 
y devuelve unicamente los correspondientes de la tala de la derecha.
	SELECT A.NOMBRE, B.HOBBY FROM <TABLA_IZQ A>
		LEFT JOIN
			<TABLA_DER B>
				ON A.ID = B.ID
                
3. RIGHT JOIN: Mantiene todos los registros de la tabla de la derecha y devuelve unicamente
los correspondientes de la tabla de la izquierda.
	SELECT A.NOMBRE, B.HOBBY FROM <TABLA_IZQ A>
		RIGHT JOIN
			<TABLA_DER B>
				ON A.ID = B.ID

4. FULL JOIN: Mantiene y devuelve todos los registros de las tablas
	SELECT A.NOMBRE, B.HOBBY FROM <TABLA_IZQ A>
		FULL JOIN
			<TABLA_DER B>
				ON A.ID = B.ID
                
5, CROSS JOIN: Devuelve el producto cartesiano de los registros de las tablas.
	SELECT A.NOMBRE, B.HOBBY FROM
		<TABLA_IZQ A>, <TABLA_DER B>
*/
USE JUGOS_VENTAS;
SELECT * FROM tabla_de_vendedores;
SELECT * FROM facturas;
SELECT * FROM tabla_de_vendedores A
	INNER JOIN
		facturas B
	ON A.MATRICULA = B.MATRICULA;
    
SELECT A.NOMBRE, B.MATRICULA, COUNT(*) FROM tabla_de_vendedores A
	INNER JOIN
		facturas B
	ON A.MATRICULA = B.MATRICULA
    GROUP BY A.NOMBRE, B.MATRICULA;
    
SELECT A.NOMBRE, B.MATRICULA, COUNT(*) FROM tabla_de_vendedores A, FACTURAS B
	WHERE A.MATRICULA = B.MATRICULA
    GROUP BY A.NOMBRE, B.MATRICULA;
    
/*	ACTIVIDAD
Obten la facturacion anual de la empresa. Ten en cuenta que el valor financiero de las ventas
consiste en multiplicar la cantidad por el precio.
*/
/* El resultado sería */
SELECT YEAR(FECHA_VENTA), SUM(CANTIDAD * PRECIO) AS FACTURACION
	FROM FACTURAS F
		INNER JOIN
			ITEMS_FACTURAS IFa
				ON F.NUMERO = IFa.NUMERO
	GROUP BY YEAR(FECHA_VENTA); /* RESULTADO OBSERVADO EN CLASE */
    
SELECT COUNT(*) FROM TABLA_DE_CLIENTES;
SELECT DISTINCT A.DNI, A.NOMBRE, B.DNI FROM TABLA_DE_CLIENTES A
	INNER JOIN
		FACTURAS B
			ON A.DNI = B.DNI;
            
SELECT DISTINCT A.DNI, A.NOMBRE, A.CIUDAD, B.DNI FROM TABLA_DE_CLIENTES A
	LEFT JOIN
		FACTURAS B
			ON A.DNI = B.DNI;
            
SELECT DISTINCT A.DNI, A.NOMBRE, A.CIUDAD, B.DNI FROM TABLA_DE_CLIENTES A
	LEFT JOIN
		FACTURAS B
			ON A.DNI = B.DNI
WHERE B.DNI IS NULL;

SELECT DISTINCT B.DNI, B.NOMBRE, B.CIUDAD, A.DNI FROM FACTURAS A
	RIGHT JOIN
		TABLA_DE_CLIENTES B
			ON A.DNI = B.DNI
WHERE A.DNI IS NULL;

SELECT * FROM TABLA_DE_CLIENTES;
SELECT * FROM TABLA_DE_VENDEDORES;
SELECT TABLA_DE_CLIENTES.NOMBRE, TABLA_DE_CLIENTES.BARRIO,
TABLA_DE_VENDEDORES.NOMBRE, TABLA_DE_VENDEDORES.BARRIO
FROM TABLA_DE_CLIENTES
	INNER JOIN
		TABLA_DE_VENDEDORES
			ON TABLA_DE_CLIENTES.BARRIO = TABLA_DE_VENDEDORES.BARRIO;
            
SELECT TABLA_DE_CLIENTES.NOMBRE, TABLA_DE_CLIENTES.BARRIO,
TABLA_DE_VENDEDORES.NOMBRE, TABLA_DE_VENDEDORES.BARRIO
FROM TABLA_DE_CLIENTES
	LEFT JOIN
		TABLA_DE_VENDEDORES
			ON TABLA_DE_CLIENTES.BARRIO = TABLA_DE_VENDEDORES.BARRIO;
            
SELECT TABLA_DE_CLIENTES.NOMBRE, TABLA_DE_CLIENTES.BARRIO,
TABLA_DE_VENDEDORES.NOMBRE, TABLA_DE_VENDEDORES.BARRIO
FROM TABLA_DE_CLIENTES
	RIGHT JOIN
		TABLA_DE_VENDEDORES
			ON TABLA_DE_CLIENTES.BARRIO = TABLA_DE_VENDEDORES.BARRIO;
            
SELECT TABLA_DE_CLIENTES.NOMBRE, TABLA_DE_CLIENTES.BARRIO,
TABLA_DE_VENDEDORES.NOMBRE, TABLA_DE_VENDEDORES.VACACIONES
FROM TABLA_DE_CLIENTES
	RIGHT JOIN
		TABLA_DE_VENDEDORES
			ON TABLA_DE_CLIENTES.BARRIO = TABLA_DE_VENDEDORES.BARRIO;
            
SELECT TABLA_DE_CLIENTES.NOMBRE, TABLA_DE_CLIENTES.BARRIO,
TABLA_DE_VENDEDORES.NOMBRE, VACACIONES
FROM TABLA_DE_CLIENTES
	RIGHT JOIN
		TABLA_DE_VENDEDORES
			ON TABLA_DE_CLIENTES.BARRIO = TABLA_DE_VENDEDORES.BARRIO;
            
SELECT TABLA_DE_CLIENTES.NOMBRE, TABLA_DE_CLIENTES.BARRIO,
TABLA_DE_VENDEDORES.NOMBRE, TABLA_DE_VENDEDORES.VACACIONES
FROM TABLA_DE_CLIENTES
	FULL JOIN /* NO FUNCIONA PORQUE EN MYSQL NO ESTA IMPLEMENTADO. 
    PARA QUE FUNCIONE SE DEBE HACER UN RIGHT JOIN Y UN LEFT JOIN EN UN MISMO COMANDO*/
		TABLA_DE_VENDEDORES
			ON TABLA_DE_CLIENTES.BARRIO = TABLA_DE_VENDEDORES.BARRIO;
 
 /* CROSS JOIN */
SELECT TABLA_DE_CLIENTES.NOMBRE, TABLA_DE_CLIENTES.CIUDAD, TABLA_DE_CLIENTES.BARRIO,
TABLA_DE_VENDEDORES.NOMBRE, VACACIONES
FROM TABLA_DE_CLIENTES, TABLA_DE_VENDEDORES
	WHERE TABLA_DE_CLIENTES.BARRIO = TABLA_DE_VENDEDORES.BARRIO;

/* ESTRUCTURA UNION:
permite unir 2 o mas tablas. Usa implicitamente DISTINCT.
El numero de campos en las tablas debe ser igual,
es decir, mismos campos y mismos tipos de datos.

<consulta1>
	UNION
<consulta2>
La estructura no repite valores

UNION ALL si repite valores:
<CONSULTA1>
	UNION ALL
<CONSULTA2>
*/

SELECT DISTINCT BARRIO FROM TABLA_DE_CLIENTES;
SELECT DISTINCT BARRIO FROM TABLA_DE_VENDEDORES;

SELECT DISTINCT BARRIO FROM TABLA_DE_CLIENTES
	UNION
SELECT DISTINCT BARRIO FROM TABLA_DE_VENDEDORES;

SELECT DISTINCT BARRIO FROM TABLA_DE_CLIENTES
	UNION ALL
SELECT DISTINCT BARRIO FROM TABLA_DE_VENDEDORES;

SELECT DISTINCT BARRIO, NOMBRE, 'CLIENTE' AS TIPO FROM TABLA_DE_CLIENTES
	UNION
SELECT DISTINCT BARRIO, NOMBRE, 'VENDEDOR' AS TIPO FROM TABLA_DE_VENDEDORES;

SELECT DISTINCT BARRIO, NOMBRE, 'CLIENTE' AS TIPO_CLIENTE FROM TABLA_DE_CLIENTES
	UNION
SELECT DISTINCT BARRIO, NOMBRE, 'VENDEDOR' AS TIPO_VENDEDOR FROM TABLA_DE_VENDEDORES;

/*
A TENER EN CUENTA AL MOMENTO DE DECLARAR UN ALIAS:
'VALOR' AS <ALIAS>
SI EN UNA CONSULTA DE VARIAS LINEAS SE UTILIZA MAS DE UN ALIAS,
SOLO SERA CONSIDERADO Y MOSTRADO EL PRIMER ALIAS EJECUTADO EN EL PERIMER SELECT.
*/

SELECT DISTINCT BARRIO, NOMBRE, 'CLIENTE' AS TIPO_CLIENTE, DNI FROM TABLA_DE_CLIENTES
	UNION
SELECT DISTINCT BARRIO, NOMBRE, 'VENDEDOR' AS TIPO_VENDEDOR, MATRICULA FROM TABLA_DE_VENDEDORES;

/* COMO HACER UN FULL JOIN */

SELECT TABLA_DE_CLIENTES.NOMBRE, TABLA_DE_CLIENTES.BARRIO,
TABLA_DE_VENDEDORES.NOMBRE, TABLA_DE_VENDEDORES.BARRIO, VACACIONES
FROM TABLA_DE_CLIENTES
	LEFT JOIN
		TABLA_DE_VENDEDORES
			ON TABLA_DE_CLIENTES.BARRIO = TABLA_DE_VENDEDORES.BARRIO
UNION
SELECT TABLA_DE_CLIENTES.NOMBRE, TABLA_DE_CLIENTES.BARRIO,
TABLA_DE_VENDEDORES.NOMBRE, TABLA_DE_VENDEDORES.BARRIO, VACACIONES
FROM TABLA_DE_CLIENTES
	RIGHT JOIN
		TABLA_DE_VENDEDORES
			ON TABLA_DE_CLIENTES.BARRIO = TABLA_DE_VENDEDORES.BARRIO;

/* SUBCONSULTAS:
Permite realizar una consulta en el interior de otra

SELECT X, Y FROM <TB1> WHERE Y IN (1,2)
SELECT X, Y FROM <TB1> WHERE Y IN (1,2,3)

Se puede seleccionar los valores de Y sin necesidad de listarlos uno por uno.
SELECT X, Y FROM <TB1> WHERE Y IN (SELECT Y FROM <TB2>
Esto es generar una consulta dentro de otra consulta

SELECT X, SUM(Y) AS NEW_Y FROM <TB1> GROUP BY X
SELECT Z.X, Z.NEW_Y FROM (SELECT X, SUM(Y) AS NEW_Y FROM <TB1> GROUP BY X) Z WHERE Z.NEW_Y = 4
*/
/* EN ESTE EJEMPLO VEMOS COMO TENDRIAMOS QUE HACER UNA CONSULTA PARA OBTENER LOS SIGUIENTES RESULTADOS */
SELECT DISTINCT BARRIO FROM TABLA_DE_VENDEDORES;
SELECT * FROM TABLA_DE_CLIENTES
	WHERE BARRIO IN ('CONDESA', 'DEL VALLE', 'CONTADERO', 'OBLATOS');
    
/* ENTONCES, COMO HACER LA SUBCONSULTA. VEMOS QUE AL USAR 'IN()' COLOCAMOS EL SELECT ANTERIOR DENTRO DE SU ESTRUCTURA
Y DE ESTA MANERA HACEMOS LA SUBCONSULTA */
SELECT * FROM TABLA_DE_CLIENTES
	WHERE BARRIO IN (SELECT DISTINCT BARRIO FROM TABLA_DE_VENDEDORES);
    
SELECT ENVASE, MAX(PRECIO_DE_LISTA) AS PRECIO_MAXIMO FROM TABLA_DE_PRODUCTOS GROUP BY ENVASE;

SELECT X.ENVASE, X.PRECIO_MAXIMO FROM (SELECT ENVASE, MAX(PRECIO_DE_LISTA) 
AS PRECIO_MAXIMO FROM TABLA_DE_PRODUCTOS GROUP BY ENVASE) X WHERE X.PRECIO_MAXIMO >=10;

/* ACTIVIDAD: Relación entre HAVING y Subconsulta
Cuál sería la consulta utilizando la subconsulta que sería equivalente a:

SELECT DNI, COUNT(*) FROM facturas
WHERE YEAR(FECHA_VENTA) = 2016
GROUP BY DNI
HAVING COUNT(*) > 2000;
*/ /* ESTE ES EL COMANDO QUE SE DEBE EJECUTAR, DE LO CONTRARIO EL ANTERIOR NO DEVOLVERA NINGUN VALOR */
SELECT X.DNI, X.CONTADOR FROM 
(SELECT DNI, COUNT(*) AS CONTADOR FROM facturas
WHERE YEAR(FECHA_VENTA) = 2016
GROUP BY DNI) X WHERE X.CONTADOR > 2000;

/* UNIENDO TABLAS Y CONSULTAS: VIEWS
Es una tabla logica que resulta de una consulta que puede ser usada posteriormente
en cualquier otra consulta. Resulta util para mostrar la base de datos sin dar acceso total 
sino solo a una parte de la base de datos.

SELECT X, SUM(Y) AS NEW_Y FROM <TB1> GROUP BY X
Al almacenar la consulta, crearemos una View y la llamaremos VW_VIEW.
La vision tiene UN COSTO DE PROCESAMIENTO, siempre que la invoquemos la misma tendra
que ejecutar su consulta (Especie de subconsulta).

SELECT * FROM VW_VIEW
SELECT VW_VIEW.X, TB3.W FROM VW_VIEW
	INNER JOIN
TB3 ON VW_VIEW.NEW_Y = TB3.Y
	WHERE TB3.Y = 16;
*/

SELECT X.ENVASE, X.PRECIO_MAXIMO FROM vw_envases_grandes X
	WHERE PRECIO_MAXIMO >=10;

SELECT A.NOMBRE_DEL_PRODUCTO, A.ENVASE, A.PRECIO_DE_LISTA, 
((A.PRECIO_DE_LISTA/B.PRECIO_MAXIMO)-1)*100 AS PORCENTAJE_DE_VARIACION FROM TABLA_DE_PRODUCTOS A
	INNER JOIN
vw_envases_grandes B
ON A.ENVASE = B.ENVASE;

/*	FUNCIONES CON STRINGS
EJEMPLO:
	SELECT CONCAT("SQL ", "TUTORIAL ", "IS ", "FUN!") AS ConcatenatedString;
*//* PRUEBA EJECUTAR ESTO */
SELECT CONCAT("SQL ", "TUTORIAL ", "IS ", "FUN!") AS ConcatenatedString;
/* RECUERDA QUE LO QUE VA DESPUES DE 'AS' SIEMPRE ES UN <ALIAS> Y PUEDES PONER LO QUE SE TE OCURRA O NECESITES */
/* OBSERVA Y EJECUTA*/
SELECT CONCAT("SQL ", "TUTORIAL ", "IS ", "FUN!") AS Hola_Soy_un_Alias;
/*
UNA FUNCION MUY UTIL Y NECESARIA SABER EN BASES DE DATOS ES LA FUNCION RTRIM() Y LTRIM()
SE UTILIZA PARA ELIMINAR ESPACIOS EN BLANCO TANTO A IZQUIERDA COMO DERECHA, MANTENIENDO UNA BASE DE DATOS LIMPIA DE CARACTERES EN BLANCO.
EJEMPLO:
	SELECT RTRIM("SQL TUTORIAL          ") AS Funcion_De_eliminar_espacios_a_la_derecha;
*/
SELECT RTRIM("SQL TUTORIAL          ") AS Funcion_De_eliminar_espacios_a_la_derecha;
/* MAS SENCILLO QUE ESTO ES USAR TRIM() QUE YA CUMPLE LA FUNCION DE AMBAS */
SELECT CONCAT("   ", "MySQL ", "TUTORIAL ", "    ") AS Hola_Soy_un_Alias;
SELECT TRIM("       MySQL TUTORIAL          ") AS Funcion_De_eliminar_espacios;

/* COMENCEMOS CON LA CLASE */
SELECT LTRIM('        MySQL ES FACIL');
SELECT RTRIM('MySQL ES FACIL        ');
SELECT TRIM('        MySQL ES FACIL        ');

SELECT CONCAT("MySQL ES FACIL ", "NO LO CREES?");

SELECT UPPER('mysql es una base de datos interesante.');
SELECT LOWER('MYSQL ES UNA BASE DE DATOS INTERESANTE.');

SELECT SUBSTRING('mysql es una base de datos interesante.', 14,4);

/* EJEMPLOS DE USO MAS REALES */
SELECT CONCAT(NOMBRE, " ", DNI) FROM TABLA_DE_CLIENTES;

/* ACTIVIDAD DE CLASE: Listando la dirección completa
Haz una consulta listando el nombre del cliente y la dirección completa (Con calle, barrio, ciudad y estado).
RESUELVO:
*/
SELECT * FROM TABLA_DE_CLIENTES;
SELECT CONCAT("Estado o Nacion: ", ESTADO, " - Nombre completo: ", NOMBRE, " - Direccion: ", DIRECCION_1, 
" - Piso/Dpto: ", DIRECCION_2, " - Barrio: ", BARRIO, " - Ciudad: ", CIUDAD) FROM TABLA_DE_CLIENTES ORDER BY ESTADO;
/*HAY QUE OPTIMIZAR YA QUE LA VISTA DE LA QUERY NO ES LA MAS PROLIJA PERO EL RESULTADO ES EL ESPERADO*/
/* RESULTADO PROPUESTO POR ALURA: */
SELECT NOMBRE, CONCAT(DIRECCION_1, ' ', BARRIO, ' ', CIUDAD, ' ', ESTADO) AS COMPLETO FROM tabla_de_clientes;

/* FUNCIONES DE FECHA
SELECT CURRENT_TIMESTAMP();
MUESTRA LA FECHA Y HORA ACTUAL.

SELECT LOCALTIMESTAMP();
MUESTRA LA FECHA Y HORA ACTUAL DEL SERVIDOR DONDE SE ENCUENTRA ALOJADO LA DB
*/
SELECT CURRENT_TIMESTAMP();
SELECT localtimestamp(); /* EN ESTE CASO COMO SE ENCUENTRA ALOJADO EN TU DISCO DURO,
EJECUTARA Y RETORNARA TU FECHA Y HORA LOCAL. PUEDES PROBAR EJECUTAR AMBAS LINEAS PARA QUE LO COMPRUEBES */

SELECT CURDATE();
SELECT current_timestamp();

SELECT YEAR(current_timestamp());
SELECT MONTH(current_timestamp());
SELECT DAY(current_timestamp());
SELECT MONTHNAME(current_timestamp());
SELECT DAYNAME(current_timestamp());

SELECT DATEDIFF(CURRENT_TIMESTAMP(), "2020-01-30"); /* ESTA FUNCION TE RETORNARA CUANTOS DIAS HAN PASADO DESDE
LA <FECHA ACTUAL>, "FECHA ESPECIFICADA" */
SELECT DATEDIFF(CURRENT_TIMESTAMP(), "1990-12-27") AS DIFERENCIA_DE_DIAS;

SELECT current_timestamp() AS DIA_HOY, date_sub(current_timestamp(), INTERVAL 1 MONTH) AS RESULTADO; /* ESTA FUNCION
LO QUE HACE ES RESTAR UN INTERVALO ESPECIFICADO */

/* APLICANDO CASOS MAS REALISTAS */
SELECT DISTINCT FECHA_VENTA, DAYNAME(FECHA_VENTA), MONTHNAME(FECHA_VENTA)
	AS MES, YEAR(FECHA_VENTA) AS AÑO FROM FACTURAS;

/* ACTIVIDAD DE CLASE: Edad de los clientes
Haz una consulta que muestre el nombre y la edad actual del cliente.
*/
SELECT * FROM TABLA_DE_CLIENTES;
/*SELECT NOMBRE AS NOMBRE_DEL_CLIENTE, current_timestamp(EDAD) AS EDAD_DEL_CLIENTE FROM TABLA_DE_CLIENTES;*/
/* MI COMANDO ELEGIDO ES ERRONEO.
LA PROPUESTA POR ALURA: */
SELECT NOMBRE, TIMESTAMPDIFF(YEAR, FECHA_DE_NACIMIENTO, CURDATE()) AS EDAD FROM  tabla_de_clientes;


















































































